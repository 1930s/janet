# Copyright (c) 2017 Calvin Rose
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

(print "\nRunning basic tests...\n")

(var num-tests-passed 0)
(var num-tests-run 0)
(def assert (fn [x e]
	(varset! num-tests-run (+ 1 num-tests-run))
	(if x
		(do
			(print "  \e[32m✔\e[0m " e)
			(varset! num-tests-passed (+ 1 num-tests-passed))
			x)
		(do
			(print "  \e[31m✘\e[0m " e)
			x))))

(assert (= 10 (+ 1 2 3 4)) "addition")
(assert (= -8 (- 1 2 3 4)) "subtraction")
(assert (= 24 (* 1 2 3 4)) "multiplication")
(assert (= 4 (<< 1 2)) "left shift")
(assert (= 1 (>> 4 2)) "right shift")
(assert (< 1 2 3 4 5 6) "less than integers")
(assert (< 1.0 2.0 3.0 4.0 5.0 6.0) "less than reals")
(assert (> 6 5 4 3 2 1) "greater than integers")
(assert (> 6.0 5.0 4.0 3.0 2.0 1.0) "greater than reals")
(assert (<= 1 2 3 3 4 5 6) "less than or equal to integers")
(assert (<= 1.0 2.0 3.0 3.0 4.0 5.0 6.0) "less than or equal to reals")
(assert (>= 6 5 4 4 3 2 1) "greater than or equal to integers")
(assert (>= 6.0 5.0 4.0 4.0 3.0 2.0 1.0) "greater than or equal to reals")

(assert (< nil false true
	(fiber (fn [x] x))
    1 1.0 "hi"
	(quote hello)
	(array 1 2 3)
	(tuple 1 2 3)
    (table "a" "b" "c" "d")
    (struct 1 2 3 4)
	(buffer "hi")
	(fn [x] (+ x x))
	+) "type ordering")

(assert (= (get {} 1) nil) "get nil from empty struct")
(assert (= (get @{} 1) nil) "get nil from empty table")
(assert (= (get {:boop :bap} :boop) :bap) "get non nil from struct")
(assert (= (get @{:boop :bap} :boop) :bap) "get non nil from table")
(assert (put @{} :boop :bap) "can add to empty table")
(assert (put @{1 3} :boop :bap) "can add to non-empty table")

(assert (not false) "false literal")
(assert true "true literal")
(assert (not nil) "nil literal")
(assert (= 7 (| 3 4)) "bit or")
(assert (= 0 (& 3 4)) "bit and")

# Set global variables to prevent some compiler optimizations that defeat point of the test
(var zero 0)
(var one 1)
(var two 2)
(var three 3)
(var plus +)
(assert (= 22 (plus one (plus 1 2 two) (plus 8 (plus zero 1) 4 three))) "nested function calls")

# Mcarthy's 91 function
(var f91 nil)
(varset! f91 (fn [n] (if (> n 100) (- n 10) (f91 (f91 (+ n 11))))))
(assert (= 91 (f91 10)), "f91(10) = 91")
(assert (= 91 (f91 100)), "f91(100) = 91")
(assert (= 91 (f91 101)), "f91(101) = 91")
(assert (= 92 (f91 102)), "f91(102) = 92")
(assert (= 93 (f91 103)), "f91(103) = 93")
(assert (= 94 (f91 104)), "f91(104) = 94")

(assert (= "hello" :hello) "keyword syntax for strings")
(assert (= '(1 2 3) (quote (1 2 3)) (tuple 1 2 3)) "quote shorthand")

((fn []
	(var accum 1)
	(var count 0)
	(while (< count 16)
		(varset! accum (<< accum 1))
		(varset! count (+ 1 count)))
	(assert (= accum 65536) "loop in closure")))

(var accum 1)
(var count 0)
(while (< count 16)
	(varset! accum (<< accum 1))
	(varset! count (+ 1 count)))
(assert (= accum 65536) "loop globally")

(assert (= (struct 1 2 3 4 5 6 7 8) (struct 7 8 5 6 3 4 1 2)) "struct order does not matter")

# Fiber tests

(def athread (thread (fn [x]
	(error (string "hello, " x)))))

(def athread-result (tran athread "world!"))

(assert (= athread-result "hello, world!") "thread error result")
(assert (= (status athread) "error") "thread error status")

# yield tests

(def t (thread (fn [] (tran nil 1) (tran nil 2) 3)))

(assert (= 1 (tran t)) "initial transfer to new thread")
(assert (= 2 (tran t)) "second transfer to thread")
(assert (= 3 (tran t)) "return from thread")
(assert (= (status t) "dead") "finished thread is dead")

# Var arg tests

(def vargf (fn [x & more] (apply + (if x x 0) 100 more)))
(assert (= 100 (vargf)) "var arg no arguments")
(assert (= 101 (vargf 1)) "var arg no packed arguments")
(assert (= 103 (vargf 1 2)) "var arg tuple size 1")
(assert (= 110 (vargf 1 2 3 4)) "var arg tuple size 3")
(assert (= 210 (vargf 1 2 3 4 10 10 10 10 10 10 10 10 10 10)) "var arg large tuple")

# Gensym tests

(assert (not= (gensym) (gensym)) "two gensyms not equal")
(assert (not= (gensym 'abc) (gensym 'abc)) "two gensyms with arg not equal")
((fn []
	(def syms (table))
	(var count 0)
	(while (< count 128)
		(set! syms (gensym 'beep) true)
		(varset! count (+ 1 count)))
	(assert (= (length syms) 128) "many symbols")))

# report

(print "\n" num-tests-passed " of " num-tests-run " tests passed\n")
(if (not (= num-tests-passed num-tests-run)) (exit! 1))
