# A .dsts file will contain VM, assembly for a dst function. This includes
# associated constants and what not. The assembler should be able to
# simply construct a FuncDef from this file. This file is also parsed
# in the same markup as dst itself (extended S expressions)
{
    arity 3
    source "source file path"
    vararg false
# Name for reference by nested funcdefs
    name outerfunc
# Contains the bytecode for this function. This can be assembly
# instructions or integers. Assembly will be converted to integer bytecodes immediately.
    bytecode [
        (load-constant 0 bork)
        (load-constant 1 bip)
        (add 0 0 1)
        (add-immediate 0 0 127)
        (push3 0 0 0)
        (push3 0 0 0)
        (push3 0 0 0)
        (syscall 1 0)
        (return 0)
    ]
# A source map is optional. The sourcemap corresponds with the byte code.
# Each instruction has two source map entries, offset start and offset end.
#    map [
#       1
#       2
#       3
#       10
#       15
#       39
#       90
#       134
#       ...
#    ]
#
# The number of slots available for the function.
# Slots can be named as well for convenience. 
     slots [
        x
        y
        z
     ]
# Captured outer environments that are referenced
     captures [   ]
# Constants are an array or tuple. For named constants, use a tuple that begins with let
# For a literal tuple, use (quote tuple), or 'tuple. Without names, constants must be indexed
# from their number
# Literal FuncEnvs and Functions may be possible later
     constants [
         :hello
         (def bork 123)
         (def bip 456)
         '(1 2 3)
         (def atuple (1 2 3))
         (567)
     ]
# Arbitrary meta data can be added to the source
     my-meta-2 @{
         1 2 3 4
     }
     my-meta {
         1 2 3 4 5 6 7 8 9 0 11 12 13 14
     }
}

