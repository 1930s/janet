# Copyright (c) 2017 Calvin Rose
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

(print "\nRunning basic tests...\n")

(var num-tests-passed 0)
(var num-tests-run 0)
(def assert (fn [x e]
	(varset! num-tests-run (+ 1 num-tests-run))
	(if x
		(do
			(print "  \e[32m✔\e[0m " e)
			(varset! num-tests-passed (+ 1 num-tests-passed))
			x)
		(do
			(print "  \e[31m✘\e[0m " e)
			x))))

(assert (= 10 (+ 1 2 3 4)) "addition")
(assert (= -8 (- 1 2 3 4)) "subtraction")
(assert (= 24 (* 1 2 3 4)) "multiplication")
(assert (= 4 (blshift 1 2)) "left shift")
(assert (= 1 (brshift 4 2)) "right shift")
(assert (< 1 2 3 4 5 6) "less than integers")
(assert (< 1.0 2.0 3.0 4.0 5.0 6.0) "less than reals")
(assert (> 6 5 4 3 2 1) "greater than integers")
(assert (> 6.0 5.0 4.0 3.0 2.0 1.0) "greater than reals")
(assert (<= 1 2 3 3 4 5 6) "less than or equal to integers")
(assert (<= 1.0 2.0 3.0 3.0 4.0 5.0 6.0) "less than or equal to reals")
(assert (>= 6 5 4 4 3 2 1) "greater than or equal to integers")
(assert (>= 6.0 5.0 4.0 4.0 3.0 2.0 1.0) "greater than or equal to reals")

(assert (< nil 1.0 1 false true "hi"
	(quote hello)
	(array 1 2 3)
	(tuple 1 2 3)
	(table "a" "b" "c" false)
	(struct 1 2)
	(thread (fn [x] x))
	(buffer "hi")
	(fn [x] (+ x x))
	+) "type ordering")

(assert (not false) "false literal")
(assert true "true literal")
(assert (not nil) "nil literal")
(assert (= 7 (bor 3 4)) "bit or")
(assert (= 0 (band 3 4)) "bit and")

(assert (= "hello" :hello) "keyword syntax for strings")
(assert (= '(1 2 3) (quote (1 2 3)) (tuple 1 2 3)) "quote shorthand")
(assert (= (symbol :banana) 'banana) "symbol function")

((fn []
	(var accum 1)
	(var count 0)
	(while (< count 16)
		(varset! accum (blshift accum 1))
		(varset! count (+ 1 count)))
	(assert (= accum 65536) "loop in closure")))

(var accum 1)
(var count 0)
(while (< count 16)
	(varset! accum (blshift accum 1))
	(varset! count (+ 1 count)))
(assert (= accum 65536) "loop globally")

(assert (= (struct 1 2 3 4 5 6 7 8) (struct 7 8 5 6 3 4 1 2)) "struct order does not matter")

# Serialization tests

(def scheck (fn [x]
    (def dat (serialize x))
    (def deser (deserialize dat))
    (assert (= x deser) (string "serialize " (description x)))
))

(scheck 1)
(scheck true)
(scheck false)
(scheck nil)
(scheck "asdasdasd")
(scheck (struct 1 2 3 4))
(scheck (tuple 1 2 3))
(scheck 123412.12)
(scheck (struct (struct 1 2 3 "a") (struct 1 2 3 "a") false 1 "asdasd" (tuple "a" "b")))
(scheck "qwertyuiopasdfghjklzxcvbnm123456789")
(scheck "qwertyuiopasdfghjklzxcvbnm1234567890!@#$%^&*()")

(def athread (thread (fn [x]
	(error (string "hello, " x)))))

(def athread-result (tran athread "world!"))

(assert (= athread-result "hello, world!") "thread error result")
(assert (= (status athread) "error") "thread error status")

# yield tests

(def t (thread (fn [] (tran nil 1) (tran nil 2) 3)))

(assert (= 1 (tran t)) "initial transfer to new thread")
(assert (= 2 (tran t)) "second transfer to thread")
(assert (= 3 (tran t)) "return from thread")
(assert (= (status t) "dead") "finished thread is dead")

# Var arg tests

(def vargf (fn [x &] (apply + (if x x 0) 100 &)))
(assert (= 100 (vargf)) "var arg no arguments")
(assert (= 101 (vargf 1)) "var arg no packed arguments")
(assert (= 103 (vargf 1 2)) "var arg tuple size 1")
(assert (= 110 (vargf 1 2 3 4)) "var arg tuple size 3")
(assert (= 210 (vargf 1 2 3 4 10 10 10 10 10 10 10 10 10 10)) "var arg large tuple")

# Gensym tests

(assert (not= (gensym) (gensym)) "two gensyms not equal")
(assert (not= (gensym 'abc) (gensym 'abc)) "two gensyms with arg not equal")
((fn []
	(def syms (table))
	(var count 0)
	(while (< count 128)
		(set! syms (gensym 'beep) true)
		(varset! count (+ 1 count)))
	(assert (= (length syms) 128) "many symbols")))

# report

(print "\n" num-tests-passed " of " num-tests-run " tests passed\n")
(if (not (= num-tests-passed num-tests-run)) (exit! 1))
